package _202210;

public class KthGrammar779 {
    public int kthGrammar(int n, int k) {
        //假如每个序列就是把一个0-indexed的，且转换关系为0-01和1-10，那么我们发现奇数位的数字永远和上一行对应的数字不同，
        // 那么就需要找到翻转了多少次，翻转奇数次则为1，偶数次为0（未翻转）
        // 上一行的idx位置在下一行的（(idx<<1)-1）处相同，在（idx<<1）处不同，那么本质就是计算（k-1）的比特数的奇偶


        //首先我们修改行的索引从 00 开始，此时原先第 pp 行的索引现在为 p - 1p−1 行，第 ii 行有 2 ^ i2
        //i
        //  位。那么对于某一行 ii 中下标为 xx 的数字，如果 x < 2^{i - 1}x<2
        //i−1
        //  那么等价于求 i - 1i−1 中下标为 xx 的数字，否则 xx 的二进制位的从右往左第 i + 1i+1 位为 11，此时需要减去该位（“翻转”一次），然后递归求解即可。所以我们可以看到最后“翻转”的总次数只和初始状态下的下标 xx 二进制表示中 11 的个数有关。因此原问题中求“翻转”的总次数就等价于求 k - 1k−1 的二进制表示中 11 的个数
        return Integer.bitCount(k-1)&1;
    }
}

package _202211;

public class IsIdealPermutation775 {
    //解法一中并没有利用到核心条件「numsnumsnums 是一个 [0,n−1][0, n - 1][0,n−1] 的排列」，我们可以从该条件以及两类倒置的定义出发进行分析。
    //
    //提示一：由“局部倒置”组成的集合为由“全局倒置”组成的集合的子集
    //任意一个“局部倒置”均满足“全局倒置”的定义，因此要判定两者数量是否相同，可转换为统计是否存在「不满足“局部倒置”定义的“全局倒置”」。
    //
    //提示二：何为不满足“局部倒置”定义的“全局倒置”
    //结合题意，若存在坐标 jjj 和 iii，满足 nums[j]>nums[i]nums[j] > nums[i]nums[j]>nums[i] 且 j+1<ij + 1 <
    // ij+1<i，那么该倒置满足“全局倒置”定义，且不满足“局部倒置”定义。
    //
    //若存在这样的逆序对，不满足，则有两类倒置数量不同。
    //
    //提示三：考虑「如何构造」或「如何避免构造」不满足“全局倒置”定义的“局部倒置”
    //如果我们能够总结出「如何构造」或「如何避免构造」一个不满足“全局倒置”定义的“局部倒置” 所需的条件，问题可以转换为检查 nums 是否满足这样的条件
    // 来得知 nums 是否存在不满足“全局倒置”定义的“局部倒置”。
    //
    //我们可以结合「numsnumsnums 是一个 [0,n−1][0, n - 1][0,n−1] 的排列」来分析，若需要避免所有 nums[j]>nums[i]nums[j] >
    // nums[i]nums[j]>nums[i] 的逆序对均不满足 j+1<ij + 1 < ij+1<i，只能是所有逆序对均由相邻数值产生。
    public boolean isIdealPermutation(int[] nums) {
        for (int i = 0; i < nums.length; i++) {
            if (Math.abs(nums[i] - i) >= 2) return false;
        }
        return true;
    }


}
